ex00: 

Para cada exercício, você deve fornecer os testes mais completos que puder.
Construtores e destruidores de cada classe devem exibir mensagens específicas. Não use a mesma mensagem para todas as classes.
Comece implementando uma classe base simples chamada Animal. Ele tem um atributo protegido:
• tipo std::string;
Implemente uma classe Dog que herda de Animal.
Implemente uma classe Cat herdada de Animal.

Essas duas classes derivadas devem definir seu campo de tipo dependendo de seu nome. Então, o tipo do Dog será inicializado como "Dog" e o tipo do Cat será inicializado como "Cat".

O tipo da classe Animal pode ser deixado em branco ou definido com o valor de sua escolha.
Todo animal deve ser capaz de usar a função de membro:
fazer som()
Imprime um som apropriado (gatos não latem)

A execução desse código deve imprimir os sons específicos das classes Dog e Cat, não do Animal.

Para garantir que você entendeu como funciona, implemente uma classe WrongCat que herda de uma classe WrongAnimal. Se você substituir o Animal e o Gato pelos errados no código acima, o WrongCat deve produzir o som WrongAnimal. EU
implementar e entregar mais testes do que os dados acima.





ex01:

Construtores e destruidores de cada classe devem exibir mensagens específicas.
Implemente uma classe Brain. Ele contém um array de 100 std::string chamado ideas.
Dessa forma, Cão e Gato terão um atributo Brain* privado.

Após a construção, Cão e Gato criarão seu Cérebro usando new Brain();
Após a destruição, Cão e Gato irão deletar seu Brain.
Em sua função principal, crie e preencha uma matriz de objetos Animal. Metade serão objetos Dog e a outra metade serão objetos Cat. No final da execução do programa, faça um loop sobre esse array e exclua todos os animais. Você deve excluir diretamente cães e gatos como Animais. Os destruidores apropriados devem ser chamados na ordem esperada.
Não se esqueça de verificar se há vazamentos de memória.
Uma cópia de um cão ou gato não deve ser superficial. Portanto, você deve testar se suas cópias são cópias profundas!



ex02:

Afinal, criar objetos Animal não faz sentido. É verdade, eles não fazem barulho!
Para evitar possíveis erros, a classe padrão Animal não deve ser instanciável.
Corrija a classe Animal para que ninguém possa instanciá-la. Tudo deve funcionar como antes.
Se desejar, você pode atualizar o nome da classe adicionando um prefixo A a Animal.



ex03:

Interfaces não existem em C++98 (nem mesmo em C++20). No entanto, classes abstratas puras são comumente chamadas de interfaces. Assim, neste último exercício, vamos tentar implementar interfaces para garantir que você tenha este módulo.
Conclua a definição da seguinte classe AMateria e implemente as funções de membro necessárias

Implemente as classes concretas de Matérias Gelo e Cura. Use seu nome em letras minúsculas ("ice" para Ice, "cure" para Cure) para definir seus tipos. Obviamente, a função de membro clone() retornará uma nova instância do mesmo tipo (ou seja, se você clonar uma Ice Materia, obterá uma nova Ice Materia).

A função de membro use(ICharacter&) exibirá:
• Gelo: "* atira uma flecha de gelo em <nome> *"
• Cura: "* cura as feridas de <nome> *"
<name> é o nome do Character passado como parâmetro. Não imprima os colchetes angulares (< e >).

Ao atribuir uma Matéria a outra, copiar o tipo não faz sentido.


Escreva a classe concreta 	Character que implementará a seguinte interface:

O Character possui um inventário de 4 slots, o que significa no máximo 4 Materias.
O inventário está vazio na construção. Eles equipam as Materias no primeiro espaço vazio que encontram. Isso significa, nesta ordem: do slot 0 ao slot 3. Caso tentem adicionar uma Materia a um inventário completo, ou usar/desequipar uma Materia inexistente, não faça nada (mas ainda assim, bugs são proibidos). A função de membro unequip() NÃO deve excluir o Materia!


Manuseie as Materias que seu personagem deixou no chão como quiser.
Salve os endereços antes de chamar unequip(), ou qualquer outra coisa, mas não esqueça que você tem que evitar vazamentos de memória.


A função de membro use(int, ICharacter&) terá que usar a Materia no slot[idx] e passar o parâmetro de destino para a função AMateria::use.

O inventário do seu personagem será capaz de suportar qualquer tipo de AMateria.

Seu Character deve ter um construtor levando seu nome como parâmetro. Qualquer cópia (usando construtor de cópia ou operador de atribuição de cópia) de um personagem deve ser profunda.
Durante a cópia, as Matérias de um Personagem devem ser excluídas antes que as novas sejam adicionadas ao seu inventário. Claro, as Materias devem ser excluídas quando um Personagem é destruído.
Escreva a classe concreta MateriaSource que implementará a seguinte interface:


• learnMateria(AMateria*)
Copia a Matéria passada como parâmetro e a armazena na memória para que possa ser clonada posteriormente. Assim como o Personagem, a MateriaSource pode conhecer no máximo 4 Materias. Eles não são necessariamente únicos.
• createMateria(std::string const &)
Retorna uma nova Matéria. Este último é uma cópia da Materia previamente aprendida pela MateriaSource cujo tipo é igual ao passado como parâmetro. Retorna 0 se o tipo for desconhecido.
Resumindo, sua MateriaSource deve ser capaz de aprender "modelos" de Materias para criá-los quando necessário. Então, você poderá gerar uma nova Matéria usando apenas uma string que identifica seu tipo.
