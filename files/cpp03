
Como você nunca terá ClapTraps suficientes, agora criará um robô derivado.
Ele será nomeado ScavTrap e herdará os construtores e o destruidor de ClapTrap. No entanto, seus construtores, destruidor e attack() imprimirão mensagens diferentes.
Afinal, ClapTraps tem consciência de sua individualidade.
Observe que o encadeamento adequado de construção/destruição deve ser mostrado em seus testes.
Quando um ScavTrap é criado, o programa começa construindo um ClapTrap. A destruição é
Em ordem inversa. Por que?
ScavTrap usará os atributos de ClapTrap (atualize ClapTrap em consequência) e
deve inicializá-los para:
	• Nome, que é passado como parâmetro para um construtor
	• Pontos de vida (100), representam a saúde do ClapTrap
	• Pontos de energia (50)
	• Dano de ataque (20)
O ScavTrap também terá sua própria capacidade especial:
	void guardGate();
Esta função de membro exibirá uma mensagem informando que o ScavTrap está agora no Gate
modo goleiro.
Não se esqueça de adicionar mais testes ao seu programa

-------------------------------------------------------------------------------------------------
Fazer ClapTraps provavelmente está começando a te dar nos nervos.
Agora, implemente uma classe FragTrap que herda de ClapTrap. É muito parecido com
ScavTrap. No entanto, suas mensagens de construção e destruição devem ser diferentes. Apropriado
o encadeamento de construção/destruição deve ser mostrado em seus testes. Quando um FragTrap é
criado, o programa começa construindo um ClapTrap. A destruição está na ordem inversa.
Mesma coisa para os atributos, mas com valores diferentes desta vez:

	• Nome, que é passado como parâmetro para um construtor
	• Pontos de vida (100), representam a saúde do ClapTrap
	• Pontos de energia (100)
	• Dano de ataque (30)
	O FragTrap também tem uma capacidade especial:
	
void highFivesGuys(void);
Esta função de membro exibe uma solicitação positiva de high fives na saída padrão.
Novamente, adicione mais testes ao seu programa.



ARG=$(shuf -i 0-1000 -n 4) && ./pushswap $ARG
ARG=$(shuf -i 0-5 -n 5) && ./push_swap $ARG
ARG=$(shuf -i 0-1000 -n 100) && ./push_swap $ARG | ./checker_linux $ARG && ./push_swap $ARG | wc -l


jhon = ver distribuicao na tela
tete = pensar no cenario | boneco
hugo = pensar nos objetos aterrissando | som do 

cami = referencia de jogos semelhantes | pesquisa de campo sobre op jogo


sexta - 14h 
