ex00:
Um primeiro exercício fácil é a maneira de começar com o pé direito.
Escreva um modelo de função easyfind que aceite um tipo T. Ele recebe dois parâmetros.
O primeiro é do tipo T e o segundo é um inteiro.
Assumindo que T é um contêiner de inteiros, esta função deve encontrar a primeira ocorrência
do segundo parâmetro no primeiro parâmetro.
Se nenhuma ocorrência for encontrada, você pode lançar uma exceção ou retornar um valor de erro
da sua escolha. Se precisar de alguma inspiração, analise como os contêineres padrão se comportam.
Claro, implemente e entregue seus próprios testes para garantir que tudo funcione conforme o esperado.

ex08:
	Desenvolva uma classe Span que possa armazenar no máximo N inteiros. N é uma variável int sem sinal e será o 	
Essa classe terá uma função de membro chamada addNumber() para adicionar um único número ao Span. Ele será usado para preenchê-lo. Qualquer tentativa de adicionar um novo elemento se já houver N elementos armazenados deve gerar uma exceção.
Em seguida, implemente duas funções de membro: shortestSpan() e LongSpan() Eles descobrirão, respectivamente, o intervalo mais curto ou o intervalo mais longo (ou distância, se preferir) entre todos os números armazenados e o retornarão. Se não houver números armazenados,
ou apenas um, nenhum span pode ser encontrado. Assim, lance uma exceção.
Claro, você escreverá seus próprios testes e eles serão muito mais completos do que os abaixo. Teste seu Span pelo menos com um mínimo de 10.000 números. Mais seria
melhor ainda.

Por último, mas não menos importante, seria maravilhoso preencher seu Span usando vários iteradores.
Fazer milhares de chamadas para addNumber() é muito chato. Implemente uma função de membro para adicionar muitos números ao seu Span em uma chamada.

Se você não tem a menor ideia, estude os Containers. algum membro
as funções usam uma variedade de iteradores para adicionar uma sequência de elementos ao contêiner.

ex03
Agora, é hora de seguir em frente com coisas mais sérias. Vamos desenvolver algo estranho.
O contêiner std::stack é muito bom. Infelizmente, é um dos únicos contêineres STL que NÃO é iterável. Isso é ruim.
Mas por que aceitaríamos isso? Especialmente se pudermos tomar a liberdade de massacrar a pilha original para criar recursos ausentes.
Para reparar essa injustiça, você deve tornar o contêiner std::stack iterável.
Escreva uma classe MutantStack. Ele será implementado em termos de um std::stack.
Ele oferecerá todas as suas funções de membro, além de um recurso adicional: iteradores.
Claro, você escreverá e entregará seus próprios testes para garantir que tudo funcione conforme o esperado.



Se você executá-lo pela primeira vez com seu MutantStack e uma segunda vez substituindo o MutantStack por, por exemplo, um std::list, as duas saídas devem ser as mesmas. Obviamente, ao testar outro contêiner, atualize o código abaixo com o correspondente
funções de membro (push() pode se tornar push_back()).







